#!/usr/bin/perl

use lib '/usr/local/pf/lib';

use strict;
use warnings;

use IO::Socket::INET;
use Net::DHCP::Packet;
use Net::DHCP::Constants;

use Net::PcapUtils;
use Net::DHCP::Packet;
use NetPacket::Ethernet qw(:strip);
use NetPacket::IP;
use NetPacket::UDP;

use pf::util;
use pf::node;

# What is the IP address of the production relay agent
our $PEER_IP = "172.21.158.7";
# We need a dummy IP in the network for the DHCP replies
# They need to go nowhere
our $DUMMY_IP = "172.21.158.4";
# This is our relay IP, who we are
our $RELAY_IP = "172.20.20.109";
# What is the DHCP server to relay to
our $DHCP_IP = "10.0.0.16";

# We bind the 67 even if we don't really listen to it since we use libpcap
# If we don't then, the clients will get ICMP unreachable when trying to contact us
my $client_sock = IO::Socket::INET->new(
        LocalAddr => "0.0.0.0",
        LocalPort => 67,
        Proto => "udp", 
        Broadcast => 1,
        Reuse => 1,
        )
    or die "socket: $@";  

       
sub process_pkt {
  my($user, $hdr, $pkt) = @_;

  print "-------------------------\n";

  my $eth = NetPacket::Ethernet->decode($pkt);
  my $ip_packet = NetPacket::IP->decode($eth->{data});
  my $udp_packet = NetPacket::UDP->decode($ip_packet->{data});
  my $dhcp_packet = Net::DHCP::Packet->new($udp_packet->{data});

  my $client_mac = clean_mac(substr($dhcp_packet->chaddr(),0,12));

  print "Packet IN (".$dhcp_packet->op.") from $ip_packet->{src_ip}! for client $client_mac\n";

  if($ip_packet->{src_ip} eq $PEER_IP){
      print "REQUEST from relay for client $client_mac \n";
      my $out_sock = IO::Socket::INET->new(
              LocalAddr => $RELAY_IP,
              PeerHost => $DHCP_IP, 
              LocalPort => 67,
              PeerPort => 67, 
              Proto => "udp", 
              Reuse => 1,
              )
          or die "socket: $@";
  
      # We add the dummy IP in the relay address
      # The DHCP server will return it there (so nowhere)
      # But the reflector will send it to us
      $dhcp_packet->giaddr($DUMMY_IP);
      
      # If the DHCP server option is there we need to replace it by the
      # real DHCP server IP, otherwise he won't know he is authoritative 
      # on this packet
      replace_option($dhcp_packet, DHO_DHCP_SERVER_IDENTIFIER, $DHCP_IP);

      $out_sock->send($dhcp_packet->serialize());
  }
  elsif ($ip_packet->{src_ip} eq $RELAY_IP){
    print "Not acting on packet because we sent the packet \n";
  }
  elsif ($dhcp_packet->op eq 1 && $ip_packet->{src_ip} eq $DHCP_IP){
    print "Not acting on packet because we're seeing the request on the DHCP server \n";
  }
  else {
      print "REPLY from server for client $client_mac \n";
      my $out_sock = IO::Socket::INET->new(
              LocalAddr => $RELAY_IP,
              PeerHost => $PEER_IP, 
              LocalPort => 67,
              PeerPort => 67, 
              Proto => "udp", 
              Broadcast => 1,
              Reuse => 1,
              )
          or die "socket: $@";  

      # We are the next server
      $dhcp_packet->siaddr($RELAY_IP);
      # We set the relay back to the first relay
      $dhcp_packet->giaddr($PEER_IP);
      
      my $node_attributes = node_attributes($client_mac);

      # We make ourselves the DHCP server so release/renew will go through us
      replace_option($dhcp_packet, DHO_DHCP_SERVER_IDENTIFIER, $RELAY_IP);

      if($node_attributes->{status} eq "unreg"){
          # When unreg, we set the lease time to 30 seconds with a 15 seconds renew
          # We also point the DNS to PacketFence so the user sees the portal
          replace_option($dhcp_packet, 58, 15);
          replace_option($dhcp_packet, 59, 30);
          replace_option($dhcp_packet, DHO_DHCP_LEASE_TIME, 30);
          replace_option($dhcp_packet, DHO_DOMAIN_NAME_SERVERS, $RELAY_IP);
      }

#      print $dhcp_packet->toString();

      $out_sock->send($dhcp_packet->serialize());
  }


}

sub replace_option {
    my ($dhcp_packet, $option_id, $new_value, $is_raw) = @_;
    $is_raw = defined($is_raw) ? 1 : 0;
    my @options;

    # We first fetch all the options and their order
    foreach my $key ( @{ $dhcp_packet->{options_order} } ) {
        push @options, {option => $key, raw_value => $dhcp_packet->getOptionRaw($key)};
    }

    # We remove them all
    # NOTE : they can't be removed in the loop above as the library skips options due to that
    for my $option_info ( @options ) {
        $dhcp_packet->removeOption($option_info->{option});
    }     

    # We re-add every option in order, replacing the one we want to replace when we see it
    for my $option_info ( @options ) {
        if($option_info->{option} eq $option_id){
            if($is_raw){
                $dhcp_packet->addOptionRaw($option_id, $new_value);
            }
            else {
                $dhcp_packet->addOptionValue($option_id, $new_value);
            }
        }
        else {
            $dhcp_packet->addOptionRaw($option_info->{option}, $option_info->{raw_value});
        }
    }


}

sub pcap_listen {
    # 67 and 68 DHCP client and server, and 767 for the udp reflector on the remote DHCP server
    Net::PcapUtils::loop(\&process_pkt, DEV => 'eth0', SNAPLEN => 1500, FILTER => 'udp port 67 or 68 or 767');
}

pcap_listen();
