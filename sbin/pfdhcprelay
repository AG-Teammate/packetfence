#!/usr/bin/perl

use lib '/usr/local/pf/lib';

use strict;
use warnings;

use IO::Socket::INET;
use Net::DHCP::Packet;
use Net::DHCP::Constants;

use Net::PcapUtils;
use Net::DHCP::Packet;
use NetPacket::Ethernet qw(:strip);
use NetPacket::IP;
use NetPacket::UDP;

use pf::util;
use pf::node;

our $PEER_IP = "172.21.158.7";
our $RELAY_IP = "172.20.20.109";
our $DHCP_IP = "10.0.0.16";

# We bind the 67
my $client_sock = IO::Socket::INET->new(
        LocalAddr => "0.0.0.0",
        LocalPort => 67,
        Proto => "udp", 
        Broadcast => 1,
        Reuse => 1,
        )
    or die "socket: $@";  

       
sub process_pkt {
  my($user, $hdr, $pkt) = @_;

  print "-------------------------\n";

  my $eth = NetPacket::Ethernet->decode($pkt);
  my $ip_packet = NetPacket::IP->decode($eth->{data});
  my $udp_packet = NetPacket::UDP->decode($ip_packet->{data});
  my $dhcp_packet = Net::DHCP::Packet->new($udp_packet->{data});

  my $client_mac = clean_mac(substr($dhcp_packet->chaddr(),0,12));

  print "Packet IN (".$dhcp_packet->op.") from $ip_packet->{src_ip}! for client $client_mac\n";

  if($ip_packet->{src_ip} eq $PEER_IP){
      print "REQUEST from relay for client $client_mac \n";
      my $out_sock = IO::Socket::INET->new(
              LocalAddr => $RELAY_IP,
              PeerHost => $DHCP_IP, 
              LocalPort => 67,
              PeerPort => 67, 
              Proto => "udp", 
              Reuse => 1,
              )
          or die "socket: $@";
  
      $dhcp_packet->giaddr("172.21.158.1");
      
      replace_option($dhcp_packet, DHO_DHCP_SERVER_IDENTIFIER, $DHCP_IP);

      $out_sock->send($dhcp_packet->serialize());
  }
  elsif ($ip_packet->{src_ip} eq $RELAY_IP){
    print "Not acting on packet because we sent the packet \n";
  }
  elsif ($dhcp_packet->op eq 1 && $ip_packet->{src_ip} eq $DHCP_IP){
    print "Not acting on packet because we're seeing the request on the DHCP server \n";
  }
  else {
      print "REPLY from server for client $client_mac \n";
      my $out_sock = IO::Socket::INET->new(
              LocalAddr => $RELAY_IP,
              PeerHost => $PEER_IP, 
              LocalPort => 67,
              PeerPort => 67, 
              Proto => "udp", 
              Broadcast => 1,
              Reuse => 1,
              )
          or die "socket: $@";  

      $dhcp_packet->siaddr($RELAY_IP);
      $dhcp_packet->giaddr($PEER_IP);
      
      my $node_attributes = node_attributes($client_mac);

      replace_option($dhcp_packet, DHO_DHCP_SERVER_IDENTIFIER, "172.20.20.109");

      if($node_attributes->{status} eq "unreg"){
          replace_option($dhcp_packet, 58, 15);
          replace_option($dhcp_packet, 59, 30);
          replace_option($dhcp_packet, DHO_DHCP_LEASE_TIME, 30);
          replace_option($dhcp_packet, DHO_DOMAIN_NAME_SERVERS, $RELAY_IP);
      }

#      print $dhcp_packet->toString();

      $out_sock->send($dhcp_packet->serialize());
  }


}

sub replace_option {
    my ($dhcp_packet, $option_id, $new_value, $is_raw) = @_;
    $is_raw = defined($is_raw) ? 1 : 0;
    my @options;
    foreach my $key ( @{ $dhcp_packet->{options_order} } ) {
        push @options, {option => $key, raw_value => $dhcp_packet->getOptionRaw($key)};
    }

    for my $option_info ( @options ) {
        $dhcp_packet->removeOption($option_info->{option});
    }     


    for my $option_info ( @options ) {
        if($option_info->{option} eq $option_id){
            if($is_raw){
                $dhcp_packet->addOptionRaw($option_id, $new_value);
            }
            else {
                $dhcp_packet->addOptionValue($option_id, $new_value);
            }
        }
        else {
            $dhcp_packet->addOptionRaw($option_info->{option}, $option_info->{raw_value});
        }
    }


}

sub pcap_listen {
    Net::PcapUtils::loop(\&process_pkt, DEV => 'eth0', SNAPLEN => 1500, FILTER => 'udp port 67 or 68 or 767');
}

pcap_listen();
