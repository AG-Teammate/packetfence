#!/usr/bin/perl

=head1 NAME

pfcache - a service that update the config cache

=head1 SYNOPSIS

pfcache [options]

 Options:
   -d      Daemonize
   -h      Help
   -v      Verbose

=cut

use warnings;
use strict;
use Getopt::Std;
#use English qw( ‐no_match_vars ); # no match avoids regex performance penalty
use File::Basename qw(basename);
use POSIX qw(:signal_h pause);
use Pod::Usage;

use constant INSTALL_DIR => '/usr/local/pf';

use lib INSTALL_DIR . "/lib";


#$thread=1;

use pf::config;
use pf::config::cached;
use pf::util;
use pf::admin_roles;
use pf::ConfigStore::AdminRoles;
use pf::ConfigStore::Authentication;
use pf::ConfigStore::FloatingDevice;
use pf::ConfigStore::Interface;
use pf::ConfigStore::Mdm;
use pf::ConfigStore::Network;
use pf::ConfigStore::Pf;
use pf::ConfigStore::Profile;
use pf::ConfigStore::SwitchOverlay;
use pf::ConfigStore::Switch;
use pf::ConfigStore::Violations;
use pf::ConfigStore::Wrix;

# initialization
# --------------
# assign process name (see #1464)
our $PROGRAM_NAME = basename($0);

# log4perl init
Log::Log4perl->init_and_watch( INSTALL_DIR . "/conf/log.conf", $LOG4PERL_RELOAD_TIMER );
my $logger = Log::Log4perl->get_logger( basename($PROGRAM_NAME) );
Log::Log4perl::MDC->put( 'proc', basename($PROGRAM_NAME) );
Log::Log4perl::MDC->put( 'tid',  threads->self->tid() );

$SIG{HUP} = \&normal_sighandler;
$SIG{INT} = \&normal_sighandler;
$SIG{TERM} = \&normal_sighandler;
$SIG{ALRM} = sub {};

my %args;
getopts( 'dhvr', \%args );

pod2usage( -verbose => 1 ) if ( $args{h} );

my $daemonize = $args{d};
my $verbose   = $args{v};
my $restart   = $args{r};
our $running = 1;

# standard signals and daemonize
daemonize() if ($daemonize);

# run the cleanup
cleanup();

END {
    if ( !$args{h} ) {
        deletepid();
        $logger->info("stopping pfcache");
    }
}

exit(0);

=head1 SUBROUTINES

=head2 cleanup

=cut

sub cleanup {
    while ($running) {
        pf::config::cached::ReloadConfigs();
        alarm $Config{'general'}{'cache_update_interval'};
        pause;
    }
}

sub daemonize {
    chdir '/' or $logger->logdie("Can't chdir to /: $!");
    open STDIN, '<', '/dev/null'
        or $logger->logdie("Can't read /dev/null: $!");
    my ($login,$pass,$uid,$gid) = getpwnam('pf')
        or die "pf not in passwd file";
    my $log_file = "$install_dir/logs/pfcache";
    open STDOUT, '>>', "$log_file"
        or $logger->logdie("Can't write to $log_file: $!");
    chown $uid, $gid, $log_file;
    defined( my $pid = fork ) or $logger->logdie("pfcache could not fork: $!");
    POSIX::_exit(0) if ($pid);
    if ( !POSIX::setsid() ) {
        $logger->error("could not start a new session: $!");
    }
    open STDERR, '>&STDOUT' or $logger->logdie("Can't dup stdout: $!");
    createpid();
}

sub normal_sighandler {
    $running = 0;
}

=back

=head1 AUTHOR

Inverse inc. <info@inverse.ca>

Minor parts of this file may have been contributed. See CREDITS.

=head1 COPYRIGHT

Copyright (C) 2005-2013 Inverse inc.

Copyright (C) 2005 Kevin Amorin

Copyright (C) 2005 David LaPorte

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
USA.

=cut

